# Fractal Gradient Descent
Work-in-progress hobby project written in Python 3, inspired by [this paper](http://demo.cs.brandeis.edu/papers/wcci98.pdf) and [this blog post](https://hardmath123.github.io/chaos-game-fractal-foliage.html). 

Fractals are images which appear similar at different scales. Fractal images can be generated by iteration over a finite set of affine transformations each on the form: 

![](https://latex.codecogs.com/svg.latex?%5Cbegin%7Bpmatrix%7D%20x_%7Bn+1%7D%5C%5C%20y_%7Bn+1%7D%20%5Cend%7Bpmatrix%7D%20%3D%20%5Cbegin%7Bpmatrix%7D%20a%20%26%20b%20%5C%5C%20c%20%26%20d%20%5Cend%7Bpmatrix%7D%20%5Cbegin%7Bpmatrix%7D%20x_%7Bn%7D%5C%5C%20y_%7Bn%7D%20%5Cend%7Bpmatrix%7D%20+%20%5Cbegin%7Bpmatrix%7D%20e%5C%5C%20f%20%5Cend%7Bpmatrix%7D)

Each affine transformation has 6 parameters, and yields an attractor in the fractal image. The method of iterating over a finite set of affine transformations is known as an iterated function system (IFS). The algorithm is simply: 
1. Start with a random point in the plane. 
2. Pick a random affine transformation from the set in the IFS. 
3. Apply the transformation on the point and draw it. 
4. Go to step 2. 

The source file `IteratedFunctionSystem.py` implements classes for affine transformations and IFS's with a finite set of affine transformations. The source file `FractalImage.py` provides a simple plotting script of the fractal images. Various different examples of IFS's are implemented including the Black Spleenworth Fern, which produces an infinitely complex pattern despite only being described by four affine transformations: 
<br><img src="https://github.com/alexander-lind/fractal-gradient-descent/raw/main/figures/fern.png" alt="Fractal image of the Black Spleenworth Fern" width="40%">

The inverse problem is then: Starting with a fractal image, can we determine the affine transformations and their parameters that generates the given fractal image? This is an interesting problem for which machine learning techniques may be useful. 
